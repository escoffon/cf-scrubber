require 'cf/scrubber/ridb/script'

module Cf::Scrubber::RIDB::Script
  # This class implements the +ridb_national_forests_db+ utility.
  # It iterates the rec areas listed in RIDB for the USFS, and generates a file containing descriptors
  # for these forests, grouped by state.
  #
  # The generated file contains a Ruby code fragment that describes the rec areas for each requested state;
  # this fragment defines a hash called +RIDB_NATIONAL_FORESTS+, whose keys are two-letter state codes,
  # and values are hashes containing the state info.
  # Currently, the state info contains the key *:rec_areas*, whose value is an array of rec area info hashes.
  # See the documentation for {Cf::Scrubber::RIDB::Script::ListNationalForests} for details on the
  # contents and structure of the rec area info.

  class PrintNationalForests < ListNationalForests
    # Parser for the RIDB national forests script.

    class Parser < Cf::Scrubber::RIDB::Script::ListNationalForests::Parser
      # Initializer.

      def initialize()
        super()
      end
    end

    protected

    # Initialize processing.
    # Cals the +super+ implementation and then emits the file header.

    def process_init
      super()

      o = self.output

      states = (self.parser.options[:states]) ? " -s #{self.parser.options[:states]}" : ''
      o.print("# generated by: ridb_national_forests_db #{states}\n")
      o.print("# generated on: #{Time.new}\n")
      o.print("RIDB_NATIONAL_FORESTS = {\n")
    end

    # Processing ended.
    # Emits the file header, and then calls the +super+ implementation.

    def process_end()
      o = self.output

      o.print("\n}\n")
      o.print("# total: #{self.total_states} states\n")

      super()
    end

    # Process national forests for a state.
    # Emits a representation of the data structure in _forests_.
    #
    # @param api [Cf::Scrubber::RIDB::API] The active instance of {Cf::Scrubber::RIDB::API}.
    # @param state [String] The two-letter state code.
    # @param forests [Array<Hash>] An array of hashes containing the national forests data structure
    #  for the state; see the class documentation for details.

    def process_national_forests(api, state, forests)
      o = self.output

      o.print(",\n") if self.total_states > 1
      o.print("  # state: #{state} (#{forests.count} forest rec areas)\n")
      o.print("  #{state}: {\n    rec_areas: [")
      forests.each_with_index do |a, a_idx|
        o.print(",") if a_idx > 0
        o.printf("\n      {\n        name: '%s',\n", a[:name].gsub("'") { "\\'" })
        o.print("        ignore: true,\n") if a[:ignore]
        o.printf("        ridb_id: %d,\n", a[:ridb_id]) if a[:ridb_id] && a[:ridb_id].is_a?(Numeric)
        o.printf("        usfs_id: %d,\n", a[:usfs_id]) if a[:usfs_id] && a[:usfs_id].is_a?(Numeric)
        o.print("        label: '#{a[:label]}',\n") if a.has_key?(:label)
        o.print("        url: '#{a[:url]}',\n") if a.has_key?(:url)
        o.print("        facilities: [")
        a[:facilities].each_with_index do |f, f_idx|
          o.print(",") if f_idx > 0
          o.printf("\n          {\n            name: '%s'", f[:name].gsub("'") { "\\'" })
          o.print(",\n            ignore: true") if f[:ignore]
          o.printf(",\n            ridb_id: %d", f[:ridb_id]) if f[:ridb_id] && f[:ridb_id].is_a?(Numeric)
          o.printf(",\n            usfs_id: %d", f[:usfs_id]) if f[:usfs_id] && f[:usfs_id].is_a?(Numeric)
          o.print(",\n            url: '#{f[:url]}'") if f.has_key?(:url)
          o.print("\n          }")
        end
        o.print("\n        ]\n      }")
      end
      o.print("\n    ]\n  }")
    end
  end
end
